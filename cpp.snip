include c.snip

# #include <...>
snippet inc
alias   #inc, #include
    #include <${1:iostream}>${0}
# #include "..."
snippet inc2
alias   #inc2, #include2
    #include "${1}"${0}

snippet     template
abbr        template <T>
    template<typename ${1:T}> 

snippet     class
abbr        class {}
    class ${1:#:name} {
        ${2}
    public:
        $1(${3});
    };
    $1::$1($3) {
        ${0:TARGET}
    }

snippet     class-without-constructor
abbr        class {}
    class ${1:#:name} {
        ${2}
    };

snippet     try
abbr        try catch
    try {
        ${1:TARGET}
    } catch (${2:e:xception}) {
        ${3}
    }

# range based for ( C++11 feature )
snippet     for_CPP11
abbr        for (:) {}
    for (${1:auto&& }${2:var} : ${3:container}) {
        ${0:TARGET}
    }

# lambda expression ( C++11 feature )
snippet     lambda
abbr        [](){}
    [${1}](${2})${3}{ ${4:TARGET} }

# scoped enumeration ( C++11 feature )
snippet     enum_scoped
abbr        enum struct {}
    enum struct { ${1:TARGET} }

# static assert ( C++11 feature )
snippet     static_assert
abbr        static_assert(,"")
    static_assert( ${1}, "${2}" );${0}

delete      namespace
snippet     namespace
abbr        namespace {}
options     head
    namespace ${1:#:name} {
        ${0:TARGET}
    } // namespace $1

snippet     static_cast
abbr        static_cast<>()
    static_cast<${1}>(${2})${0}

snippet     reinterpret_cast
abbr        reinterpret_cast<>()
    reinterpret_cast<${1}>(${2})${0}

snippet     const_cast
abbr        const_cast<>()
    const_cast<${1}>(${2})${0}

snippet     dynamic_cast
abbr        dynamic_cast<>()
    dynamic_cast<${1}>(${2})${0}

snippet     helloworld
abbr        #include<iostream> int main...
    #include <iostream>

    int main(int argc, char const* argv[])
	{
        std::cout << "hello, world!" << std::endl;
        return 0;
    }

snippet     p
options     head
  std::cout << ${0:TARGET} << std::endl;


#------------------string--------------------
snippet lcs
abbr Longest Common Sbusequence
    int lcs(string s,string s2,int len) {
		int c[len+1][len+1];	
		int m = s.size();
		int n = s2.size();
  
		int ret = 0;
		s = ' ' + s;
		s2 = ' ' + s2;
  
		REP(i,1,m+1) c[i][0] = 0;
		REP(j,1,n+1) c[0][j] = 0;
  
		REP(i,1,m+1) {
			REP(j,1,n+1) {
				if(s[i] == s2[j]) c[i][j] = c[i-1][j-1] + 1;
				else c[i][j] = max(c[i-1][j],c[i][j-1]);
				ret = max(ret,c[i][j]);
		    }
	    }
  
		return ret;
    }

snippet split
abbr string split
    vector<string> split(const string &str, char delim) {
		vector<string> res;
		size_t current = 0, found;
		while((found = str.find_first_of(delim, current)) != string::npos) {
			res.push_back(string(str, current, found - current));
			current = found + 1;
		}
		res.push_back(string(str, current, str.size() - current));
		return res;
    }


snippet samesplit
abbr samesplit
    vector<string> samesplit(string s) {
		vector<string> ret;
		rep(i,s.size()) {
			stringstream ss;
			ss << s[i];
			REP(j,i+1,s.size()) {
				if(s[i] == s[j]) {
					ss << s[j];
					i++;
				}
				else break;
			}
			ret.push_back(ss.str());
		}
		return ret;
	}

#---------- data struct ---------------

snippet     unionfind
abbr        UnionFind
    struct UnionFind {
		vector<int> par,rank;
		int N;
  
		UnionFind(int n) {
			N = n;
			par.resize(n);
			rank.resize(n);
   
			rep(i,n) {
				par[i] = i;
				rank[i] = 0;
			}
		}
  
		int find(int x) {
			if(par[x] == x) return x;
			else return par[x] = find(par[x]);
		}
  
		void unite(int x,int y) {
			x = find(x);
			y = find(y);
   
			if(x == y) return;
   
			if(rank[x] < rank[y]) {
				par[x] = y;
			}
			else {
				par[y] = x;
				if(rank[x] == rank[y]) rank[x]++;
			}
		}
  
		bool same(int x,int y) {
			return find(x) == find(y);
		}
  
		int size() {
			int cnt = 0;
			rep(i,N) if(find(i) == i) cnt++;
			return cnt;
		}
    };

snippet     RMQ
abbr        RangeMinimumQuery
    struct RMQ {
		int n;
		vector<int> dat;

		RMQ(int n_) {
			n = 1;
			while(n < n_) n *= 2;
   
			dat.resize(n*4);
			rep(i,n*4) dat[i] = INF;
		}
  
		void update(int k,int a) {
			int i = k+n-1;
			dat[i] = a;
   
			while(i > 0) {
				i = (i-1) / 2;
				dat[i] = min(dat[i*2+1],dat[i*2+2]);
			}
		}
  
		//[a,b)
		//query(a,b,0,0,n)
		int query(int a,int b,int k,int l,int r)
		{
			if(r <= a || b <= l) return INF;
   
			if(a <= l && r <= b) return dat[k];
			else { 
				int vl = query(a,b,k*2+1,l,(l+r)/2);
				int vr = query(a,b,k*2+2,(l+r)/2,r);
				return min(vl,vr);
			}
		}
    };

snippet BIT
abbr Binary Indexed Tree
    struct BIT {
		vector<int> bit;
  
		BIT(int n) : bit(n+1) {}
  
		int sum(int i) {
			int s = 0;
			while(i > 0) {
				s += bit[i];
				i -= i & -i;
			}
			return s;
		}
  
		void add(int i,int x) {
			while(i <= bit.size()) {
				bit[i] += x;
				i += i & -i;
			}
		}
    };

snippet Trie
abbr Trie Tree
    struct Trie {
		Trie *next[26];
		bool end;
  
		Trie() {
			fill(next,next+26,(Trie *)0);
		}
  
		void insert(string &s,int i) {
			if(i == s.size()) {
				this->end = true;
				return;
			}
   
			if(this->next[s[i]-'a'] == NULL) {
				this->next[s[i]-'a'] = new Trie();
			}
   
			this->next[s[i]-'a']->insert(s,i+1);
		}
  
		bool find(string &s,int i,int cnt) {
			if(cnt > 1) return false;

			if(i == s.size()) {
				if(cnt == 1 && this->end) return true;
				else return false;
			}
   
			rep(j,3) {
				if(this->next[j] != NULL) {
					if(s[i]-'a' == j) {
						if(this->next[j]->find(s,i+1,cnt)) return true;
					}
			    	else {
						if(this->next[j]->find(s,i+1,cnt+1)) return true;
					}
				}
			}
			return false;
		}
    };




#------------- geometory------------------
snippet to_rad
abbr deg->rad
    double to_rad(double deg) {
		return deg*PI/180;
	}

snippet equals
abbr geo equals
    #define equals(a,b) fabs((a) - (b)) < EPS

snippet     Point
abbr        point2
    struct Point {
		double x, y;
  
		Point(double x=0, double y=0) : x(x), y(y) {}
  
		Point operator+(const Point &o) const { return Point(x+o.x, y+o.y); }

		Point operator-(const Point &o) const { return Point(x-o.x, y-o.y); }

		Point operator*(const double m) const { return Point(x*m, y*m); }

		Point operator/(const double d) const { return Point(x/d, y/d); }

		bool operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }
  
		bool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }
  
		double cross(const Point &o) const { return x * o.y - y * o.x; }
  
		double dot(const Point &o) const { return x * o.x + y * o.y; }

		double atan() const { return atan2(y, x); }

		double norm() const { return sqrt(dot(*this)); }

		double distance(const Point &o) const { return (o - (*this)).norm(); }

		double area(const Point &a,const Point &b) {
			Point p = a - (*this), p2 = b - (*this); 
			return p.cross(p2);
		}
  
		double area_abs(const Point &a,const Point &b) const {
			Point p = a - (*this), p2 = b - (*this);
			return fabs(p.cross(p2)) / 2.0;
		}	
  
		//線分abが自身に含まれているのかどうか判断する
		int between(const Point &a,const Point &b) {
			if(area(a,b) != 0) return 0;
   
			if(a.x != b.x)  return ((a.x <= x) && (x <= b.x) || (a.x >= x) && (x >= b.x));
			else return ((a.y <= y) && (y <= b.y) || (a.y >= y) && (y >= b.y));
		}      
    
		double distance_seg(const Point& a,const Point& b) {
			if((b-a).dot(*this-a) < EPS) {
				return (*this-a).norm();
			}
			if((a-b).dot(*this-b) < EPS) {
				return (*this-b).norm();
			}
			return abs((b-a).cross(*this-a)) / (b-a).norm();
		}

		bool hitPolygon(const Point& a,const Point& b,const Point& c) {
			double t = (b-a).cross(*this-b);
			double t2 = (c-b).cross(*this-c);
			double t3 = (a-c).cross(*this-a);	

			if((t > 0 && t2 > 0 && t3 > 0) || ( t < 0 && t2 < 0 && t3 < 0)) {
				return true;
			}

			return false;
		}
    };
   
snippet     ccw
abbr        clockwise
    int ccw(Point a,Point b,Point c) {
		b = b-a;
		c = c-a;
  
		if(b.cross(c) > 0.0) return +1;	//conter clockwise
		if(b.cross(c) < 0.0) return -1;	//clockwise
		if(b.dot(c) < 0.0) return +2;	//a on Seg(b,c)
		if(b.norm() < c.norm()) return -2;	//b on Seg(a,c)
		return 0;	//c on Seg(a,b)
    }

snippet polygonArea
abbr geometory
    double polygonArea(const vector<Point>& p) {
		int n = p.size();
		double ret = 0.0;
		for(int i=0; i<n; ++i) {
			ret += p[i].cross(p[(i+1)%n]);
		}

		return abs(ret) / 2.0;
	}

snippet convex_hull
abbr convex_hull
    vector<Point> convex_hull(vector<Point> ps) {   
		int N = ps.size();
		sort(ps.begin(),ps.end());
  
		int k = 0;
		vector<Point> convex(N*2);
  
		rep(i,N) {
			while (2 <= k && (convex[k-1] - convex[k-2]).cross(ps[i] - convex[k-1]) <= 0 ) {
				k--;
			}
			convex[k++] = ps[i];
		}

		for(int i = N-2,t = k; 0 <= i;i--) {
			while (t < k && (convex[k-1] - convex[k-2]).cross(ps[i] - convex[k-1]) <= 0 ) {
				k--;
			}
			convex[ k++ ] = ps[i];
		}
  
		convex.resize(k-1);
		return convex;
	}

snippet Seg
abbr segment2
    struct Seg {
		Point a,b;
  
		Seg (Point a, Point b) : a(a),b(b) {}
  
		bool isOrthogonal(Seg &s) { return equals((b - a).dot(s.b - s.a),0.0); }
  
		bool isParallel(Seg &s) { return equals((b-a).cross(s.b - s.a),0.0); }

		bool isIntersect(Seg &s) {
			if(s.a.between(a,b) || s.b.between(a,b) || a.between(s.a,s.b) || b.between(s.a,s.b)) {
				return true;
			}
			return ((a-b).cross(s.a-a) * (a-b).cross(s.b-a) < EPS) && ((s.b-s.a).cross(a-s.a)*(s.b-s.a).cross(b-s.a) < EPS);
		}
  
		bool distance(Seg &s) {
			if((*this).isIntersect(s)) return 0.0;
   
			return min(min(a.distance_seg(s.a,s.b),b.distance_seg(s.a,s.b)),min(s.a.distance_seg(a,b),s.b.distance_seg(a,b)));
		}
  
		Point getCrossPoint(Seg &s) {
			Point p = s.b - s.a;
			double d = abs(p.cross(a-s.a));
			double d2 = abs(p.cross(b-s.a));
   
			double t = d / (d+d2);
			return a + (b-a)*t;
		}        
    };

#------------- graph theory------------------

snippet edge
abbr edge
    struct edge {
		int from,to;
		int cost;

		edge(int t,int c) : to(t),cost(c) {}
		edge(int f,int t,int c) : from(f),to(t),cost(c) {}
  
		bool operator<(const edge &e) const {
			return cost < e.cost;
		}
	};

snippet dijkstra
abbr G,d and edge
    void dijkstra(int s,int n) {
		priority_queue<P,vector<P>,greater<P> > que;
		fill(d,d+n,INF);
  
		d[s] = 0;
		que.push(P(0,s));
  
		while(que.size()) {
			P p = que.top();
			que.pop();
   
			int v = p.second;
			if(d[v] < p.first) continue;
   
			rep(i,G[v].size()) {
				edge e = G[v][i];
				if(d[e.to] > d[v] + e.cost) {
					d[e.to] = d[v] + e.cost;
					que.push(P(d[e.to],e.to));
				}
			}
		}
  }

snippet get_path
abbr prev
    vector<int> get_path(int t) {
		vector<int> path;
		for(;t!=-1;t=prev[t]) path.push_back(t);
		reverse(path.begin(),path.end());
		return path;
    }

snippet     kruskal
abbr        kruskal
    int kruskal(int n,vector<edge> v) {
		sort(v.begin(),v.end());
		UnionFind uf(n);
  
		int ret = 0;
		rep(i,v.size()) {
			edge e = v[i];
			if(!uf.same(e.from,e.to)) {
				uf.unite(e.from,e.to);
				ret += e.cost;
			}
		}
		return ret;
    }

snippet     max_flow
abbr        s:0->t:n+m+1
    struct edge {
		int to,cap,rev;
		
		edge(int t,int c,int r) {
			to = t;
			cap = c;
			rev = r;
		}
    };

    vector<edge> G[105];
    bool used[105];

    void add_edge(int from,int to,int cap) {
		G[from].push_back(edge(to,cap,G[to].size()));
		G[to].push_back(edge(from,0,G[from].size()-1));
    }

    int dfs(int v,int t,int f) {
		if(v == t) return f;
		used[v] = true;
  
		rep(i,G[v].size()) {
			edge &e = G[v][i];
			if(!used[e.to] && e.cap > 0) {
				int d = dfs(e.to,t,min(f,e.cap));
				if(d > 0) {
					e.cap -= d;   
					G[e.to][e.rev].cap += d; 
					return d;
				}
			}
		}
		return 0;
    }

    int max_flow(int s,int t) {
		int flow = 0;
		for(;;) {
			memset(used,0,sizeof(used));
			int f = dfs(s,t,INF);
			if(f == 0) return flow;
			flow += f;
		}
    }

# ------------------- number theory ----------------

snippet Eratosthenes
abbr prime
    bool prime[10000000];
    void Eratosthenes(int n {
		rep(i,n) prime[i] = true;
		prime[1] = false;
  
		REP(i,2,(int)sqrt(n)) {
			if(prime[i]) {
				for(int j=0;i*(j+2)<n;j++) {
					prime[i*(j+2)] = 0;
				}
			}
		}
	}

snippet lcm
abbr lcm
    int lcm(int m,int n) {
		if(m == 0 || n == 0) return 0;
		return ((m / __gcd(m,n)) * n);
    }

snippet extgcd
abbr a*x+b*y=1
    ll extgcd(ll a,ll b,ll &x,ll &y) {
		ll g = a;
		x = 1,y = 0;

		if(b != 0) {
			g = extgcd(b,a%b,y,x);
			y -= (a / b) * x;
		}
  
		return g;
    }


