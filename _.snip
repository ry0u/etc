# Global snippets

snippet     date
options     word
    `strftime("%d %b %Y")`

snippet     date_full
alias       df
options     word
    `strftime("%Y-%m-%dT%H:%M:%S")`

snippet     date_day
alias       dd
options     word
    `strftime("%Y-%m-%d")`

snippet     date_time
alias       dt
options     word
    `strftime("%H:%M:%S")`

snippet     lastmod
abbr        Last modified time
alias       lmod
    Last Modified: `strftime("%Y-%m-%dT%H:%M:%S")`

snippet     filename
alias       fname
options     word
    `bufname('%') =='[Command Line]' ? expand('#:t:r:r:r') : expand('%:t:r:r:r')`${0}

snippet     filename_upper_camel
alias       fnameuc
options     word
    `substitute(bufname('%') =='[Command Line]' ? expand('#:t:r:r:r') : expand('%:t:r:r:r'), '\%(^\(.\)\|_\(.\)\)', '\u\1\u\2', 'g')`${0}

snippet     filename_lower_camel
alias       fnamelc
options     word
    `substitute(bufname('%') =='[Command Line]' ? expand('#:t:r:r:r') : expand('%:t:r:r:r'), '\%(_\(.\)\)', '\u\1', 'g')`${0}

snippet     temp
abbr        problem
    #include <iostream>
    #include <string>
    #include <vector>
    #include <algorithm>
    
    #define REP(i,k,n) for(int i=k;i<n;i++)
    #define rep(i,n) for(int i=0;i<n;i++)

    using namespace std;

    int main()
    {
        int n;
        cin >> n;
        
        ${0:TARGET}
        return 0;
    }

snippet tempnm
abbr problem
    #include <iostream>
    #include <string>
    #include <vector>
    #include <algorithm>
    
    #define REP(i,k,n) for(int i=k;i<n;i++)
    #define rep(i,n) for(int i=0;i<n;i++)

    using namespace std;

    int main()
    {
        int n,m;
        cin >> n >> m;
        ${0} 
        return 0;
    }

snippet aoj
abbr AIZE JUDGE ONLINE
    #include <iostream>
    #include <string>
    #include <vector>
    #include <algorithm>

    #define REP(i,k,n) for(int i=k;i<n;i++)
    #define rep(i,n) for(int i=0;i<n;i++)

    using namespace std;

    int main()
    {
        int n;
        while(cin >> n && n)
        {
            ${0:TARGET}
        }

        return 0;
    }

snippet split
abbr string split
    vector<string> split(const string &str, char delim)
    {
	    vector<string> res;
	    size_t current = 0, found;
	    while((found = str.find_first_of(delim, current)) != string::npos)
	    {
		    res.push_back(string(str, current, found - current));
		    current = found + 1;
	    }
	    res.push_back(string(str, current, str.size() - current));
	    return res;
    }

snippet edge
abbr edge
    struct edge
    {
        int from,to;
        int cost;

        edge(int t,int c) : to(t),cost(c) {}
        edge(int f,int t,int c) : from(f),to(t),cost(c) {}

        bool operator<(const edge &e) const
        {
            return cost < e.cost;
        }
    };

snippet dijkstra
abbr G,d and edge
    void dijkstra(int s,int n)
    {
	    priority_queue<P,vector<P>,greater<P> > que;
	    fill(d,d+n,INF);

	    d[s] = 0;
	    que.push(P(0,s));

	    while(que.size())
    	{
	    	P p = que.top();
	    	que.pop();
    
		    int v = p.second;
		    if(d[v] < p.first) continue;

		    rep(i,G[v].size())
		    {
			    edge e = G[v][i];
			    if(d[e.to] > d[v] + e.cost)
			    {
				    d[e.to] = d[v] + e.cost;
				    que.push(P(d[e.to],e.to));
			    }
		    }
	    }
    }

snippet get_path
abbr prev
    vector<int> get_path(int t)
    {
	    vector<int> path;
	    for(;t!=-1;t=prev[t]) path.push_back(t);
	    reverse(path.begin(),path.end());
	    return path;
    }

snippet     kruskal
abbr        kruskal
    int kruskal(int n,vector<edge> v)
    {
    	sort(v.begin(),v.end());
	    UnionFind uf(n);
	
	    int ret = 0;
	    rep(i,v.size())
	    {
		    edge e = v[i];
		    if(!uf.same(e.from,e.to))
		    {
			    uf.unite(e.from,e.to);
			    ret += e.cost;
		    }
	    }

	    return ret;
    }


snippet Eratosthenes
abbr prime
    bool prime[10000000];
    void Eratosthenes(int n)
    {
        rep(i,n) prime[i] = true;
        prime[1] = false;
 
        REP(i,2,(int)sqrt(n))
        {
            if(prime[i])
            {
                for(int j=0;i*(j+2)<n;j++)
                {
                    prime[i*(j+2)] = 0;
                }
            }
        }
    }

snippet lcm
abbr lcm
    int lcm(int m,int n)
    {
	    if(m == 0 || n == 0) return 0;
	    return ((m / __gcd(m,n)) * n);
    }

snippet extgcd
abbr a*x+b*y=1
    ll extgdc(ll a,ll b,ll &x,ll &y)
    {
	    ll g = a;
	    x = 1,y = 0;

	    if(b != 0) 
	    {
		    g = extgdc(b,a%b,y,x);
		    y -= (a / b) * x;
	    }
    
	    return g;
    }

snippet to_rad
abbr deg->rad
    double to_rad(double deg)
    {
        return deg*PI/180;
    }

snippet equals
abbr geo equals
    #define equals(a,b) fabs((a) - (b)) < EPS

snippet ccw
abbr conterclockwise
    int ccw(Point a,Point b,Point c)
    {
        b = b-a;
        c = c-a;

        if(b.cross(c) > 0.0) return +1;	//conter clockwise
        if(b.cross(c) < 0.0) return -1;	//clockwise
        if(b.dot(c) < 0.0) return +2;	//a on Seg(b,c)
        if(b.norm() < c.norm()) return -2;	//b on Seg(a,c)
        return 0;	//c on Seg(a,b)
    }
    

snippet Point
abbr geometory
    struct Point
    {
        double x, y;

        Point(double x=0, double y=0) : x(x), y(y) {}

        Point operator+(const Point &o) const { return Point(x+o.x, y+o.y); }

        Point operator-(const Point &o) const { return Point(x-o.x, y-o.y); }

        Point operator*(const double m) const { return Point(x*m, y*m); }

        Point operator/(const double d) const { return Point(x/d, y/d); }

        Point operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }

        bool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }

        double cross(const Point &o) const { return x * o.y - y * o.x; }

        double dot(const Point &o) const { return x * o.x + y * o.y; }

        double atan() const { return atan2(y, x); }

        double deg() const { return atan() * 180.0 / (acos(-1) * 4.0); }

        double norm() const { return sqrt(dot(*this)); }

        double distance(const Point &o) const { return (o - (*this)).norm(); }

        double area(const Point &a,const Point &b)
        {
            Point p = a - (*this), p2 = b - (*this); 
            return p.cross(p2);
        }

        double area_abs(const Point &a,const Point &b) const
        {
            Point p = a - (*this), p2 = b - (*this);
            return fabs(p.cross(p2)) / 2.0;
        }	

        //線分abが自身に含まれているのかどうか判断する
        int between(const Point &a,const Point &b)
        {
            if(area(a,b) != 0) return 0;

            if(a.x != b.x)
            {
                return ((a.x <= x) && (x <= b.x) || (a.x >= x) && (x >= b.x));
            }
            else
            {
                return ((a.y <= y) && (y <= b.y) || (a.y >= y) && (y >= b.y));
            }
        }      

        double distance_seg(const Point& a,const Point& b)
        {
            if((b-a).dot(*this-a) < EPS)
            {
                return (*this-a).norm();
            }
            if((a-b).dot(*this-b) < EPS)
            {
                return (*this-b).norm();
            }
            return abs((b-a).cross(*this-a)) / (b-a).norm();
        }

        bool hitPolygon(const Point& a,const Point& b,const Point& c)
        {
            double t = (b-a).cross(*this-b);
            double t2 = (c-b).cross(*this-c);
            double t3 = (a-c).cross(*this-a);
            if((t > 0 && t2 > 0 && t3 > 0) || ( t < 0 && t2 < 0 && t3 < 0))
            {
                return true;
            }

            return false;
        }
    };
    


snippet Seg
abbr geometory
    struct Seg
    {
        Point a,b;
 
        Seg (Point a, Point b) : a(a),b(b) {}
 
	    bool isIntersect(Seg &s)
	    {
		    if(s.a.between(a,b) || s.b.between(a,b) || a.between(s.a,s.b) || b.between(s.a,s.b))
		    {
			    return true;
		    }

		    return ((a-b).cross(s.a-a) * (a-b).cross(s.b-a) < EPS) && ((s.b-s.a).cross(a-s.a)*(s.b-s.a).cross(b-s.a) < EPS);
	    }
        
        Point getCrossPoint(Seg &s)
	    {
		    Point p = s.b - s.a;
		    double d = abs(p.cross(a-s.a));
		    double d2 = abs(p.cross(b-s.a));

		    double t = d / (d+d2);
		    return a + (b-a)*t;
	    }
    };

snippet polygonArea
abbr geometory
    double polygonArea(const vector<Point>& p)
    {
        int n = p.size();
        double ret = 0.0;
        for(int i=0; i<n; ++i)
        {
            ret += p[i].cross(p[(i+1)%n]);
        }

        return abs(ret) / 2.0;
    }

snippet convex_hull
abbr convex_hull
    vector<Point> convex_hull(vector<Point> ps)
    {   
	    int N = ps.size();
	    sort(ps.begin(),ps.end());

	    int k = 0;
	    vector<Point> convex(N*2);

	    rep(i,N)
        {
            while (2 <= k && (convex[k-1] - convex[k-2]).cross(ps[i] - convex[k-1]) <= 0 )
            {
                k--;
            }
            convex[k++] = ps[i];
        }
 
        for(int i = N-2,t = k; 0 <= i;i--)
        {
            while (t < k && (convex[k-1] - convex[k-2]).cross(ps[i] - convex[k-1]) <= 0 )
            {
                k--;
            }
            convex[ k++ ] = ps[i];
        }
 
        convex.resize(k-1);
        return convex;
    }

snippet BIT
abbr Binary Indexed Tree
    struct BIT
    {
	    vector<int> bit;

	    BIT(int n) : bit(n+1) {}

	    int sum(int i)
	    {
		    int s = 0;
		    while(i > 0)
		    {
			    s += bit[i];
			    i -= i & -i;
		    }
	    	return s;
	    }

	    void add(int i,int x)
	    {
		    while(i <= bit.size())
		    {
			    bit[i] += x;
		    	i += i & -i;
		    }
    	}
    };

snippet Trie
abbr Trie Tree
    struct Trie
    {
	    Trie *next[26];
	    bool end;

	    Trie()
	    {
		    fill(next,next+26,(Trie *)0);
	    }

    	void insert(string s,int i)
    	{
	    	if(i == s.size()) 
	    	{
		    	this->end = true;
		    	return;
		    }

		    if(this->next[s[i]-'a'] == NULL)
		    {
			    this->next[s[i]-'a'] = new Trie();
		    }

		    this->next[s[i]-'a']->insert(s,i+1);
	    }
        
        bool find(string s,int i,int cnt)
    	{
	    	if(cnt > 1) return false;

		    if(i == s.size())
	    	{
		    	if(cnt == 1 && this->end) return true;
		    	else return false;
		    }

		    rep(j,3)
	    	{
		    	if(this->next[j] != NULL)
			    {
				    if(s[i]-'a' == j) 
				    {
					    if(this->next[j]->find(s,i+1,cnt)) return true;
			    	}
			    	else 
			    	{
				    	if(this->next[j]->find(s,i+1,cnt+1)) return true;
				    }
			    }
		    }
		    return false;
	    }
    };
    
