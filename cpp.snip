include c.snip

# #include <...>
snippet inc
alias   #inc, #include
    #include <${1:iostream}>${0}
# #include "..."
snippet inc2
alias   #inc2, #include2
    #include "${1}"${0}

snippet     template
abbr        template <T>
    template<typename ${1:T}> 

snippet     class
abbr        class {}
    class ${1:#:name} {
        ${2}
    public:
        $1(${3});
    };
    $1::$1($3) {
        ${0:TARGET}
    }

snippet     class-without-constructor
abbr        class {}
    class ${1:#:name} {
        ${2}
    };

snippet     try
abbr        try catch
    try {
        ${1:TARGET}
    } catch (${2:e:xception}) {
        ${3}
    }

# range based for ( C++11 feature )
snippet     for_CPP11
abbr        for (:) {}
    for (${1:auto&& }${2:var} : ${3:container}) {
        ${0:TARGET}
    }

# lambda expression ( C++11 feature )
snippet     lambda
abbr        [](){}
    [${1}](${2})${3}{ ${4:TARGET} }

# scoped enumeration ( C++11 feature )
snippet     enum_scoped
abbr        enum struct {}
    enum struct { ${1:TARGET} }

# static assert ( C++11 feature )
snippet     static_assert
abbr        static_assert(,"")
    static_assert( ${1}, "${2}" );${0}

delete      namespace
snippet     namespace
abbr        namespace {}
options     head
    namespace ${1:#:name} {
        ${0:TARGET}
    } // namespace $1

snippet     static_cast
abbr        static_cast<>()
    static_cast<${1}>(${2})${0}

snippet     reinterpret_cast
abbr        reinterpret_cast<>()
    reinterpret_cast<${1}>(${2})${0}

snippet     const_cast
abbr        const_cast<>()
    const_cast<${1}>(${2})${0}

snippet     dynamic_cast
abbr        dynamic_cast<>()
    dynamic_cast<${1}>(${2})${0}

snippet     helloworld
abbr        #include<iostream> int main...
    #include <iostream>

    int main(int argc, char const* argv[])
    {
        std::cout << "hello, world!" << std::endl;
        return 0;
    }

snippet     p
options     head
  std::cout << ${0:TARGET} << std::endl;


#------------------string--------------------
snippet lcs
abbr Longest Common Sbusequence
    int lcs(string s,string s2,int len)
    {
	    int c[len+1][len+1];
	    int m = s.size();
	    int n = s2.size();

	    int ret = 0;
	    s = ' ' + s;
	    s2 = ' ' + s2;

	    REP(i,1,m+1) c[i][0] = 0;
	    REP(j,1,n+1) c[0][j] = 0;

	    REP(i,1,m+1)
	    {
		    REP(j,1,n+1)
		    {
			    if(s[i] == s2[j]) c[i][j] = c[i-1][j-1] + 1;
			    else c[i][j] = max(c[i-1][j],c[i][j-1]);

			    ret = max(ret,c[i][j]);
		    }
	    }

	    return ret;
    }


#---------- data struct ---------------

snippet     unionfind
abbr        UnionFind
    struct UnionFind
    {
        vector<int> par,rank;
        int N;

        UnionFind(int n)
        {
            N = n;
            par.resize(n);
            rank.resize(n);

            rep(i,n)
            {
                par[i] = i;
                rank[i] = 0;
            }
        }

        int find(int x)
        {
            if(par[x] == x) return x;
            else return par[x] = find(par[x]);
        }

        void unite(int x,int y)
        {
            x = find(x);
            y = find(y);

            if(x == y) return;

            if(rank[x] < rank[y])
            {
                par[x] = y;
            }
            else
            {
                par[y] = x;
                if(rank[x] == rank[y]) rank[x]++;
            }
        }

        bool same(int x,int y)
        {
            return find(x) == find(y);
        }

        int size()
        {
            int cnt = 0;
            rep(i,N) if(find(i) == i) cnt++;
            
            return cnt;
        }

    };


#------------- geometory------------------

snippet     Point
abbr        point2
    struct Point
    {
	    double x, y;

	    Point(double x=0, double y=0) : x(x), y(y) {}

	    Point operator+(const Point &o) const { return Point(x+o.x, y+o.y); }

	    Point operator-(const Point &o) const { return Point(x-o.x, y-o.y); }

	    Point operator*(const double m) const { return Point(x*m, y*m); }

	    Point operator/(const double d) const { return Point(x/d, y/d); }
        
        bool operator<(const Point &o) const { return x != o.x ? x < o.x : y < o.y; }

        bool operator==(const Point &o) const { return fabs(x-o.x) < EPS && fabs(y-o.y) < EPS; }

        double cross(const Point &o) const { return x * o.y - y * o.x; }

	    double dot(const Point &o) const { return x * o.x + y * o.y; }

	    double atan() const { return atan2(y, x); }

	    double norm() const { return sqrt(dot(*this)); }

	    double distance(const Point &o) const { return (o - (*this)).norm(); }

	    double area(const Point &a,const Point &b)
	    {
		    Point p = a - (*this), p2 = b - (*this); 
		    return p.cross(p2);
	    }

	    double area_abs(const Point &a,const Point &b) const
	    {
		    Point p = a - (*this), p2 = b - (*this);
		    return fabs(p.cross(p2)) / 2.0;
	    }	

	    //線分abが自身に含まれているのかどうか判断する
	    int between(const Point &a,const Point &b)
        {
            if(area(a,b) != 0) return 0;

	    	if(a.x != b.x)  return ((a.x <= x) && (x <= b.x) || (a.x >= x) && (x >= b.x));
		    else return ((a.y <= y) && (y <= b.y) || (a.y >= y) && (y >= b.y));
	    }      
    	
        double distance_seg(const Point& a,const Point& b)
        {
	    	if((b-a).dot(*this-a) < EPS)
	    	{
		    	return (*this-a).norm();
		    }
		    if((a-b).dot(*this-b) < EPS)
	    	{
		    	return (*this-b).norm();
	    	}
		    return abs((b-a).cross(*this-a)) / (b-a).norm();
        }
        
        bool hitPolygon(const Point& a,const Point& b,const Point& c)
        {
	    	double t = (b-a).cross(*this-b);
	    	double t2 = (c-b).cross(*this-c);
	    	double t3 = (a-c).cross(*this-a);
	    	if((t > 0 && t2 > 0 && t3 > 0) || ( t < 0 && t2 < 0 && t3 < 0))
	    	{
	    		return true;
	    	}

		    return false;
	    }
    };
   
snippet     ccw
abbr        clockwise
    int ccw(Point a,Point b,Point c)
    {
	    b = b-a;
	    c = c-a;

	    if(b.cross(c) > 0.0) return +1;	//conter clockwise
	    if(b.cross(c) < 0.0) return -1;	//clockwise
	    if(b.dot(c) < 0.0) return +2;	//a on Seg(b,c)
	    if(b.norm() < c.norm()) return -2;	//b on Seg(a,c)
	    return 0;	//c on Seg(a,b)
    }

snippet Seg
abbr segment2
    struct Seg
    {
	    Point a,b;

	    Seg (Point a, Point b) : a(a),b(b) {}

	    bool isOrthogonal(Seg &s) { return equals((b - a).dot(s.b - s.a),0.0); }

	    bool isParallel(Seg &s) { return equals((b-a).cross(s.b - s.a),0.0); }
	
	    bool isIntersect(Seg &s)
	    {
		    if(s.a.between(a,b) || s.b.between(a,b) || a.between(s.a,s.b) || b.between(s.a,s.b))
		    {
			    return true;
		    }
		    return ((a-b).cross(s.a-a) * (a-b).cross(s.b-a) < EPS) && ((s.b-s.a).cross(a-s.a)*(s.b-s.a).cross(b-s.a) < EPS);
	    }

	    bool distance(Seg &s)
	    {
		    if((*this).isIntersect(s)) return 0.0;

		    return min(min(a.distance_seg(s.a,s.b),b.distance_seg(s.a,s.b)),
		    		min(s.a.distance_seg(a,b),s.b.distance_seg(a,b)));
	    }

        Point getCrossPoint(Seg &s)
	    {
		    Point p = s.b - s.a;
		    double d = abs(p.cross(a-s.a));
		    double d2 = abs(p.cross(b-s.a));

		    double t = d / (d+d2);
		    return a + (b-a)*t;
	    }        
    };

